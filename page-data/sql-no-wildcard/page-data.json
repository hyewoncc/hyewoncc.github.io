{"componentChunkName":"component---src-templates-blog-template-js","path":"/sql-no-wildcard/","result":{"data":{"cur":{"id":"daccaece-c833-5d4f-b63f-7213dd06dafe","html":"<p>지금까지 DB를 사용하는 미션에서 컬럼 수가 적기에 <code class=\"language-text\">select * from table</code> 문을 자주 썼다. 그런데 <code class=\"language-text\">*</code>로 모든 컬럼을 가져오는 것 보다 컬럼을 명시해 가져오는 게 낫다는 영문 포스팅을 제이슨이 공유해주셔서 읽었다.<br>\n<a href=\"https://dzone.com/articles/why-you-should-not-use-select-in-sql-query-1\">7 Reasons Why Using SELECT * FROM TABLE in SQL Query Is a Bad Idea</a> 다음은 해당 포스팅을 전체 번역한 것이다.</p>\n<h2 id=\"select--from-table-쿼리문을-쓰는-게-좋지-않은-7가지-이유\" style=\"position:relative;\"><a href=\"#select--from-table-%EC%BF%BC%EB%A6%AC%EB%AC%B8%EC%9D%84-%EC%93%B0%EB%8A%94-%EA%B2%8C-%EC%A2%8B%EC%A7%80-%EC%95%8A%EC%9D%80-7%EA%B0%80%EC%A7%80-%EC%9D%B4%EC%9C%A0\" aria-label=\"select  from table 쿼리문을 쓰는 게 좋지 않은 7가지 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SELECT * FROM TABLE 쿼리문을 쓰는 게 좋지 않은 7가지 이유</h2>\n<p>인터넷에서 <code class=\"language-text\">SELECT *</code> 쿼리문을 쓰는 게 나쁘니 피하라고 하는 많은 글을 봐왔다. 그 대신 정확한 컬럼을 나열해야 한다. 이는 내가 주니어 개발자에게 가르치기도 하는 좋은 제안이자 좋은 SQL 작성 습관 중 하나인데, 많은 사람들이 그 이유는 설명하지 않는다.</p>\n<!--more-->\n<p>왜 쿼리문에서 <code class=\"language-text\">SELECT *</code>을 쓰면 안되는지 이유를 설명하지 않고 SQL 개발자들을 설득하기란 어려운데, 대개 Oracle database에서 <code class=\"language-text\">SELECT * from EMP</code>를 실행하는 것으로 SQL 학습을 시작하기 때문이다.</p>\n<p>이 글에서 왜 <code class=\"language-text\">SELECT *</code> 쿼리문을 쓰면 안되는지 실질적인 이유를 제시해 인식의 차이를 메우고자 한다. 아래는 <code class=\"language-text\">SELECT * from a table</code>을 쓰지 말아야 할 설득력 있는 몇 가지 이유이다.</p>\n<h3 id=\"1-불필요한-io-인풋-아웃풋\" style=\"position:relative;\"><a href=\"#1-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-io-%EC%9D%B8%ED%92%8B-%EC%95%84%EC%9B%83%ED%92%8B\" aria-label=\"1 불필요한 io 인풋 아웃풋 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 불필요한 I/O (인풋, 아웃풋)</h3>\n<p><code class=\"language-text\">SELECT *</code>를 사용하면 사용되지 않을 불필요한 데이터를 반환할 수 있다. 하지만 그 데이터를 불러오는 데는 비용이 들고, 페이지나 인덱스에서 데이터를 읽어오는 동안 IO 사이클이 낭비된다. 이는 쿼리 속도를 낮출 수도 있다. 먄악 쿼리가 실제로 어떻게 실행되는지, <a href=\"https://dzone.com/refcardz/event-stream-processing-essentials\">쿼리 엔진이 쿼리문을 어떤 순서로 어떻게 처리</a>하는지… 등을 모른다면 <a href=\"https://www.amazon.com/Performance-Explained-Everything-Developers-about/dp/3950307826/?tag=javamysqlanta-20\">SQL Performance Explained(번역서 없음)</a> 같은 책이나 유데미의 <a href=\"https://www.udemy.com/course/the-complete-sql-bootcamp/?LSNPUBID=JVFxdTr9V80&#x26;ranEAID=JVFxdTr9V80&#x26;ranMID=39197&#x26;ranSiteID=JVFxdTr9V80-cg.Nnfk_77u8fZ5YccVnaw&#x26;utm_medium=udemyads&#x26;utm_source=aff-campaign\">The Complete SQL BootCamp(한국어 지원 없음)</a> 강의를 들어보길 바란다.</p>\n<h3 id=\"2-네트워크-트래픽-증가\" style=\"position:relative;\"><a href=\"#2-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%8A%B8%EB%9E%98%ED%94%BD-%EC%A6%9D%EA%B0%80\" aria-label=\"2 네트워크 트래픽 증가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 네트워크 트래픽 증가</h3>\n<p><code class=\"language-text\">SELECT *</code>는 명백하게 클라이언트에서 필요한 것 보다 많은 데이터를 반환하므로 네트워크 대역폭을 더 많이 사용한다. 이는 클라이언트 어플리케이션에 전송되는 데 더 큰 시간이 든다는 말도 된다. 여기서 말한 클라이언트에는 당신이 쿼리를 실행하는 <code class=\"language-text\">SQL Server Maganement, Toad, SQL Developer for Oracle</code>같은 쿼리 에디터와 <code class=\"language-text\">Java 어플리케이션</code>등이 포함된다.</p>\n<h3 id=\"3-어플리케이션-메모리-낭비\" style=\"position:relative;\"><a href=\"#3-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%82%AD%EB%B9%84\" aria-label=\"3 어플리케이션 메모리 낭비 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 어플리케이션 메모리 낭비</h3>\n<p>사용하지 않을 데이터를 저장하고 있느라 어플리케이션의 메모리가 낭비된다.</p>\n<h3 id=\"4-resultset의-컬럼-순서에-의존하는-결과\" style=\"position:relative;\"><a href=\"#4-resultset%EC%9D%98-%EC%BB%AC%EB%9F%BC-%EC%88%9C%EC%84%9C%EC%97%90-%EC%9D%98%EC%A1%B4%ED%95%98%EB%8A%94-%EA%B2%B0%EA%B3%BC\" aria-label=\"4 resultset의 컬럼 순서에 의존하는 결과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. ResultSet의 컬럼 순서에 의존하는 결과</h3>\n<p>그래서는 안되지만 어플리케이션이 <code class=\"language-text\">SELECT *</code>쿼리를 사용하며 컬럼 순서에 의존하고 있다면, 컬럼 추가나 순서 변경이 result set에 영향을 미친다.</p>\n<h3 id=\"5-테이블에-새로운-컬럼을-추가하면-뷰에-오류-발생\" style=\"position:relative;\"><a href=\"#5-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90-%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%BB%AC%EB%9F%BC%EC%9D%84-%EC%B6%94%EA%B0%80%ED%95%98%EB%A9%B4-%EB%B7%B0%EC%97%90-%EC%98%A4%EB%A5%98-%EB%B0%9C%EC%83%9D\" aria-label=\"5 테이블에 새로운 컬럼을 추가하면 뷰에 오류 발생 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 테이블에 새로운 컬럼을 추가하면 뷰에 오류 발생</h3>\n<p><code class=\"language-text\">SELECT *</code>를 뷰(<a href=\"https://www.java67.com/2012/11/what-is-difference-between-view-vs-materialized-view-database-sql.html\">select 문을 실행한 가상 테이블</a>)에 사용하면 새로운 컬럼을 추가하거나 기존 컬럼을 삭제했을 때 알아채기 힘든 오류를 발생시킨다. 뷰가 깨지는 대신에 틀린 결과를 반환하기 때문이다. 이를 피하려면 스키마바인딩을 사용해라. <code class=\"language-text\">SELECT *</code>을 사용하는 것도 막아준다.</p>\n<h3 id=\"6-join-쿼리-충돌\" style=\"position:relative;\"><a href=\"#6-join-%EC%BF%BC%EB%A6%AC-%EC%B6%A9%EB%8F%8C\" aria-label=\"6 join 쿼리 충돌 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. JOIN 쿼리 충돌</h3>\n<p><code class=\"language-text\">SELECT *</code>를 <code class=\"language-text\">JOIN</code> 쿼리에서 사용하면 같은 컬럼 이름을 가진 여러 테이블이 충돌을 일으킬 수 있다. <code class=\"language-text\">straight query(서브쿼리가 없는 쿼리)</code>를 사용하면 충돌은 없겠지만, <code class=\"language-text\">Common Table Expression</code>이나 <code class=\"language-text\">파생 테이블</code>에서 한 컬럼을 기준으로 정렬하려고 할때 추가적인 조치가 필요해진다.</p>\n<h3 id=\"7-테이블-간에-데이터를-복사할-때-문제-발생\" style=\"position:relative;\"><a href=\"#7-%ED%85%8C%EC%9D%B4%EB%B8%94-%EA%B0%84%EC%97%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%B3%B5%EC%82%AC%ED%95%A0-%EB%95%8C-%EB%AC%B8%EC%A0%9C-%EB%B0%9C%EC%83%9D\" aria-label=\"7 테이블 간에 데이터를 복사할 때 문제 발생 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. 테이블 간에 데이터를 복사할 때 문제 발생</h3>\n<p>한 테이블에서 다른 테이블로 데이터를 복사할 때 <code class=\"language-text\">SELECT * into INSERT .. SELECT</code>문을 흔히 사용하는데, 두 테이블 간에 컬럼 순서가 다르면 잠재적으로 틀린 데이터를 복사할 수 있다. 몇 개발자들은 <code class=\"language-text\">EXISTS clause</code>에서 <code class=\"language-text\">SELECT * vs. SELECT 1</code>사용하는 게 <em>정적 값을 검사하는 추가 작업을 하지 않아(DB를 잘 몰라 의역합니다)</em> 더 빠르다 생각하는데, 예전에는 맞는 얘기였으나, 요새는 <code class=\"language-text\">EXISTS</code>문에 대한 처리가 잘 되어 있어 <code class=\"language-text\">select</code>문과 완전히 무관하다.</p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p>위와 같은 이유로 <code class=\"language-text\">SELECT *</code>문의 사용을 지양해야 한다. <code class=\"language-text\">*</code> 와일드카드를 사용하는 것 보다 정확한 컬럼명을 쓰는 것이 언제나 낫다. 쿼리문 수행이 개선될 뿐 아니라 코드도 명확해진다. 거기다 특히 뷰가 있는 상황에서 테이블에 새로운 컬럼을 추가했을 때도 문제가 없기에, 코드의 유지보수 측면에서도 도움이 된다.</p>\n<br/>\n<p>컬럼이 2개인 테이블이 있을 만큼 대부분 컬럼 수가 많지 않아, 별 생각 없이 <code class=\"language-text\">*</code>을 많이 사용했는데 지양해야 할 분명한 이유를 알았다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#select--from-table-%EC%BF%BC%EB%A6%AC%EB%AC%B8%EC%9D%84-%EC%93%B0%EB%8A%94-%EA%B2%8C-%EC%A2%8B%EC%A7%80-%EC%95%8A%EC%9D%80-7%EA%B0%80%EC%A7%80-%EC%9D%B4%EC%9C%A0\">SELECT * FROM TABLE 쿼리문을 쓰는 게 좋지 않은 7가지 이유</a></p>\n<ul>\n<li><a href=\"#1-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-io-%EC%9D%B8%ED%92%8B-%EC%95%84%EC%9B%83%ED%92%8B\">1. 불필요한 I/O (인풋, 아웃풋)</a></li>\n<li><a href=\"#2-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%8A%B8%EB%9E%98%ED%94%BD-%EC%A6%9D%EA%B0%80\">2. 네트워크 트래픽 증가</a></li>\n<li><a href=\"#3-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%82%AD%EB%B9%84\">3. 어플리케이션 메모리 낭비</a></li>\n<li><a href=\"#4-resultset%EC%9D%98-%EC%BB%AC%EB%9F%BC-%EC%88%9C%EC%84%9C%EC%97%90-%EC%9D%98%EC%A1%B4%ED%95%98%EB%8A%94-%EA%B2%B0%EA%B3%BC\">4. ResultSet의 컬럼 순서에 의존하는 결과</a></li>\n<li><a href=\"#5-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90-%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%BB%AC%EB%9F%BC%EC%9D%84-%EC%B6%94%EA%B0%80%ED%95%98%EB%A9%B4-%EB%B7%B0%EC%97%90-%EC%98%A4%EB%A5%98-%EB%B0%9C%EC%83%9D\">5. 테이블에 새로운 컬럼을 추가하면 뷰에 오류 발생</a></li>\n<li><a href=\"#6-join-%EC%BF%BC%EB%A6%AC-%EC%B6%A9%EB%8F%8C\">6. JOIN 쿼리 충돌</a></li>\n<li><a href=\"#7-%ED%85%8C%EC%9D%B4%EB%B8%94-%EA%B0%84%EC%97%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%B3%B5%EC%82%AC%ED%95%A0-%EB%95%8C-%EB%AC%B8%EC%A0%9C-%EB%B0%9C%EC%83%9D\">7. 테이블 간에 데이터를 복사할 때 문제 발생</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></p>\n</li>\n</ul>\n</div>","excerpt":"지금까지 DB를 사용하는 미션에서 컬럼 수가 적기에  문을 자주 썼다. 그런데 로 모든 컬럼을 가져오는 것 보다 컬럼을 명시해 가져오는 게 낫다는 영문 포스팅을 제이슨이 공유해주셔서 읽었다. 7 Reasons Why Using SELECT * FROM TABLE in SQL Query Is a Bad Idea 다음은 해당 포스팅을 전체 번역한 것이다. SELECT * FROM TABLE 쿼리문을 쓰는 게 좋지 않은 7가지 이유 인터넷에서  쿼리문을 쓰는 게 나쁘니 피하라고 하는 많은 글을 봐왔다. 그 대신 정확한 컬럼을 나열해야 한다. 이는 내가 주니어 개발자에게 가르치기도 하는 좋은 제안이자 좋은 SQL 작성 습관 중 하나인데, 많은 사람들이 그 이유는 설명하지 않는다. 왜 쿼리문에서 을 쓰면 안되는지 이유를 설명하지 않고 SQL 개발자들을 설득하기란 어려운데, 대개 Oracle database에서 를 실행하는 것으로 SQL 학습을 시작하기 때문이다. 이 글에서 왜  쿼리문을 쓰…","frontmatter":{"date":"May 25, 2022","title":"[SQL] SELECT * 쓰지 말자","categories":"ETC","author":"써머","emoji":"headers/sql-no-wildcard.png"},"fields":{"slug":"/sql-no-wildcard/"}},"next":{"id":"1b911b70-995d-517b-9927-cdf37dda6734","html":"<p>우테코 레벨1 웹체스 미션에서 일급 컬렉션에서 특정 요소를 <code class=\"language-text\">Optional&lt;T></code>로 꺼내는 메서드를 작성했다. 그런데 해당 요소를 그냥 꺼내는 메서드가 따로 있었고, 이름이 겹치고 싶지 않아 생각하다 <code class=\"language-text\">find</code>를 붙였다. 레벨2에서 DB를 본격적으로 사용하며 <code class=\"language-text\">Dao</code>객체에서 데이터 조회를 할 때, <code class=\"language-text\">find</code>와 <code class=\"language-text\">get</code> 중 무엇을 쓸지 고민했다. <code class=\"language-text\">get</code>은 <code class=\"language-text\">getter</code>처럼 느껴져서 <code class=\"language-text\">find</code>를 사용했는데, <code class=\"language-text\">DDD</code>의 <code class=\"language-text\">Repository</code> 패턴을 보니 <code class=\"language-text\">get</code>을 쓰는 경우가 많았다. 그래서 둘의 차이를 찾아봤다.</p>\n<!--more-->\n<h2 id=\"find-vs-get\" style=\"position:relative;\"><a href=\"#find-vs-get\" aria-label=\"find vs get permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>find vs get</h2>\n<p><a href=\"https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html\">스프링 Data의 <code class=\"language-text\">CRUD repository</code></a> 인터페이스는 <code class=\"language-text\">Optional&lt;T></code>를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">CrudRepository</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span>ID<span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token class-name\">Optional</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findById</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Iterable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>반면 같은 스프링 Data의 <a href=\"https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html\">JPA repository</a>에서는 T를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">JpaRepository</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span>ID<span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token class-name\">T</span> <span class=\"token function\">getOne</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ID</span> id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">CrudRepository</code>는 찾는 값이 없을 경우 <code class=\"language-text\">빈 Optional</code>을, <code class=\"language-text\">JpaRepository</code>는 찾는 값이 없을 경우 <code class=\"language-text\">예외를 발생</code>한다는 차이가 있다. 여기서 볼 수 있듯이 일반적으로 반환 값이 없을 수 있는 경우 <code class=\"language-text\">find</code>을, 항상 있어야 하는 경우 <code class=\"language-text\">get</code>을 붙인다. <code class=\"language-text\">find</code>를 쓰면 api 사용자에게 이름을 통해 반환값이 없을 수 있음을 알려 줄 수 있는 것이다.<br>\n반면, 반환형이 <code class=\"language-text\">List</code>같은 컬렉션이라면 값이 없어도 <code class=\"language-text\">null</code>이 아닌 <code class=\"language-text\">빈 컬렉션</code>을 반환하면 된다.</p>\n<h2 id=\"optional\" style=\"position:relative;\"><a href=\"#optional\" aria-label=\"optional permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optional</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAADrUlEQVQ4yx2Q2VNadwCF72s7ZppUzSRTU5cYTSJGEFBEDSBBZEsUAlwu62VxIWwCIbgHlUSsNjVp+9A+2CaZ6Uwf+if+vo4+fXPmzPkejvTX+aH49/cO//xyLI43czgsM+gmtYyMPsA0Y2KjWCaupnG6nDiXHJhMBiwWMz6fC4N+As3YKFbbU1xuJ8WNHNKV8L8/PvDn+13hsc8yMjqCwTiJTvcEr9dNJrdKLJmiUN4kmVKxWObQasdYsD8l8HIZx+ICEUXhZSjMi+UVpK8XbfH1ok0y4BYazUMmtOOMaUbRXnHsIQ6HnXQ2y9qrAl6fD43mESaTHn9gmWg8RjgcYGXlOUFZwbpgR7o8b4lCIsDwYJ9QI8tsNyrMmI3c67vD8P1+jFM6ovE4aiZHWIkiR6P4XnjxeF1UKiV++/Uj66tpvD4P4YiCtFNUxfij+wwNDYigy8LF2TsODw+wLVjQTU4wN2fC53Ojquq1eDVfIJcvkMmmOTvr8Pnz3yQiAV4sP8fr8yLZZ3Wit7ebH/v7hHdhmnZrl9OfOrxpNpDlEMlMhkQ2i8/vR11bQ45ECMshNtazfPz0icvLS4LLbhaXnDicDqS+uz3i5ndddPd8L55Oa9mulzj7+YxEQqG8WWZrb5ed4/dsHb1jp9Vis1oiqgTJ53N8/vKFztFbbPMmxifGeSnLSLdu3hBdXd9y+3aPGBzoIx5w0Ww22N7bp/bmDSE5iBJTSK9mSKRihOUg8bjM6nqW09MTOof7WC1zDAz2o9U+QbrdfVPc6PqGnp5bYni4n3nDQ+JKgGgsQjwZJyIHsC/MX39ZrZUJBVdQ1QTF4jqKEkQO+fH4POgNeobuDyIN3bsrfrjTS29vjxgdGcKofczslBarWc/jxw94Nm/E47RTrFTptA94ohlBifjZbdaoVCvUmztkNkqshMJYbVakkmIV5aidctQhXqe97L8KUk152Vnzc5XrKTcHBZmTrTValQibKRfHtQSnzSwHRZnzvQIfDqu8rSap5/xIjaRBNNUp9nJmsZczs5udoV20c1JZ5Lzu4rS6xGHexv7qHK28jU7Nec2d7ByvE9NUZB3V6CQlWct6YBypFNGLasxIIzUjttJmtjNm3m5YOa256NSWeF9x0i47Oam6Oal56NTctMuLtF7Z2V+30lDN1BMmNmNTlCJ6pHxIKyqKnmrMKOqJKZqqie3sLMfFZ7wrO2iXHRwVnl0LjoqOa1m75LjuDzZsNJKmqy0VxUA1Ps3/NawztqMl+MYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cat\"\n        title=\"cat\"\n        src=\"/static/95113747cc9ce0c0ec8e59b6f7e2a0c7/37523/img.png\"\n        srcset=\"/static/95113747cc9ce0c0ec8e59b6f7e2a0c7/e9ff0/img.png 180w,\n/static/95113747cc9ce0c0ec8e59b6f7e2a0c7/f21e7/img.png 360w,\n/static/95113747cc9ce0c0ec8e59b6f7e2a0c7/37523/img.png 720w,\n/static/95113747cc9ce0c0ec8e59b6f7e2a0c7/5a190/img.png 800w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<div style=\"text-align:center; font-style:italic; color:grey;\">대표적 Optional인 슈뢰딩거의 고양이</div>\n<p><code class=\"language-text\">Optional</code>에 대해 한 번 정리하려 했었는데, <code class=\"language-text\">find~</code> 메서드에서 <code class=\"language-text\">Optional</code>을 쓰는 김에 이펙티브 자바를 참고해 작성했다.</p>\n<h3 id=\"optional이란\" style=\"position:relative;\"><a href=\"#optional%EC%9D%B4%EB%9E%80\" aria-label=\"optional이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optional이란</h3>\n<p><code class=\"language-text\">Optional&lt;T></code>은 null이 아닌 T 참조를 하나 담거나 아무것도 담지 않을 수 있는 클래스이다. 보통은 <code class=\"language-text\">T</code>를 반환해야 하지만 특정 조건에서는 아무것도 반환하지 않아야 할 때 <code class=\"language-text\">T</code>대신 <code class=\"language-text\">Optional&lt;T></code>를 반환하도록 선언하면 된다. <code class=\"language-text\">Optional</code>은 정적 팩토리 메서드로 생성할 수 있다.</p>\n<ul>\n<li><code class=\"language-text\">Optional.empty()</code> : 빈 옵셔널 생성</li>\n<li><code class=\"language-text\">Optional.of(T)</code> : T가 든 옵셔널 생성</li>\n<li><code class=\"language-text\">Optional.ofNullable(T)</code> : T가 든 옵셔널 생성, <code class=\"language-text\">null</code>값이 들어갈 수도 있을 때 사용</li>\n</ul>\n<p>그냥 <code class=\"language-text\">of(T)</code>와 <code class=\"language-text\">ofNullable(T)</code>를 구분해 사용하는 것이 중요하다. <code class=\"language-text\">Optional</code>을 쓰는데는 <code class=\"language-text\">NullPointerException</code> 체크의 번거로움을 생략하는 목적이 있는데, <code class=\"language-text\">of(T)</code>에 <code class=\"language-text\">null</code>을 넣으면 <code class=\"language-text\">NullPointerException</code>이 발생해 하나마나가 되기 때문이다.</p>\n<h3 id=\"효과적으로-사용하기\" style=\"position:relative;\"><a href=\"#%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"효과적으로 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>효과적으로 사용하기</h3>\n<p>처음 <code class=\"language-text\">Optional</code>을 알게 되었을 때는 <code class=\"language-text\">isPresent()</code>나 <code class=\"language-text\">isEmpty()</code>로 분기문을 만들어 처리했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>optionalPiece<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"해당 말은 존재하지 않습니다.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그런데 <code class=\"language-text\">Optional</code>이 제공하는 메서드를 이용해서 효율적으로 처리할 수 있는 방법이 있었다. 위 예시처럼 분기문으로 처리하면 사실 try~catch로 예외처리 하는 것과 다를 바가 없다고 생각한다.</p>\n<ul>\n<li><code class=\"language-text\">orElse</code>로 기본값 정하기</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> name <span class=\"token operator\">=</span> optionalName<span class=\"token punctuation\">.</span><span class=\"token function\">orElse</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"익명\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">orElseGet</code>으로 기본값 정하기</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> name <span class=\"token operator\">=</span> optionalName<span class=\"token punctuation\">.</span><span class=\"token function\">orElseGet</span><span class=\"token punctuation\">(</span><span class=\"token function\">generateRandomName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">orElse</code>에 메서드를 넣으면 <code class=\"language-text\">Optional</code>안에 실제로 값이 있건 없건 일단 실행되는 것에 유의해서 사용하자. <code class=\"language-text\">orElseGet</code>은 <code class=\"language-text\">Optional</code>에 값이 없어야만 실행된다.</p>\n<ul>\n<li><code class=\"language-text\">orElseThrow</code>로 예외 던지기</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> name <span class=\"token operator\">=</span> optionalName<span class=\"token punctuation\">.</span><span class=\"token function\">orElseThrow</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">IllegalArgumentException</span><span class=\"token operator\">::</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"주의사항\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD\" aria-label=\"주의사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주의사항</h3>\n<ul>\n<li>컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입을 옵셔널로 감싸기 금지</li>\n</ul>\n<p>그냥 빈 컬렉션이나 배열을 사용하는 것이 낫다.</p>\n<ul>\n<li>박싱된 기본 타입을 옵셔널로 다시 감싸기 금지</li>\n</ul>\n<p>값을 두 겹이나 감싸기 보다 <code class=\"language-text\">OptionalInt, OptionalLong, OptionalDouble</code>을 사용하자.</p>\n<ul>\n<li>컬렉션의 키, 값, 원소나 배열의 원소로 사용 금지</li>\n</ul>\n<p>복잡성만 높여서 혼란과 오류 가능성만 키운다.</p>\n<ul>\n<li>메서드 파라미터나 인스턴스 필드로 사용 금지</li>\n</ul>\n<p>메서드 내에서 옵셔널 분기 처리를 하는 건 생산성이 저하되며, 필드로 쓰기엔 선택형 반환값으로 설계되었기에 직렬화가 구현되지 않았다.</p>\n<h2 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h2>\n<ul>\n<li>이펙티브 자바 3판 : 아이템 55. 옵셔널 반환은 신중히 하라</li>\n<li><a href=\"https://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments\">stackoverflow : Why shoud java 8’s Optional not be used in arguments</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#find-vs-get\">find vs get</a></p>\n</li>\n<li>\n<p><a href=\"#optional\">Optional</a></p>\n<ul>\n<li><a href=\"#optional%EC%9D%B4%EB%9E%80\">Optional이란</a></li>\n<li><a href=\"#%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">효과적으로 사용하기</a></li>\n<li><a href=\"#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD\">주의사항</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\">참고자료</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"May 23, 2022","title":"Optional과 메서드 네이밍 find vs get","categories":"Java","author":"써머","emoji":"headers/optional-and-method-naming.png"},"fields":{"slug":"/optional-and-method-naming/"}},"prev":{"id":"1edd5815-991a-5bfd-bddf-48c3cf82d2d2","html":"<p>DB를 연동하고 스프링을 쓰기 시작하면서 어플리케이션의 구조가 복잡해졌다. 그에 따라 테스트도 다양한 어노테이션을 활용하여 작성해야 했는데, 처음에는 예제를 보며 따라했다. 그러다 각 어노테이션의 정확한 역할과 적용되는 방식이 궁금해 미션을 진행하며 사용한 세 테스트용 어노테이션을 학습했다.</p>\n<h2 id=\"jdbctest\" style=\"position:relative;\"><a href=\"#jdbctest\" aria-label=\"jdbctest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@JdbcTest</h2>\n<blockquote>\n<p>JDBC 기반 컴포넌트만 테스트하는 JDBC 테스트를 위한 어노테이션이다. 이 어노테이션을 사용하면 auto-configuration이 비활성화 되고, JDBC 테스트와 관련된 configuration만 적용된다. 기본적으로 <code class=\"language-text\">@JdbcTest</code>가 붙은 테스트는 트랜젝션 처리가 되고, 각 테스트가 죵로된 후 롤백을 시행한다. 또한 명시됐거나 자동 설정된 DataSource 대신 인메모리 DB를 사용하게 된다.<code class=\"language-text\">@AutoConfigureTestDatabase</code>를 사용하면 이런 설정을 덮어쓸 수 있다.  <!--more-->\n전체 어플리케이션 설정을 사용하면서 인메모리 DB를 사용하고 싶다면, 이 어노테이션 대신 <code class=\"language-text\">@SpringBootTest</code>와 <code class=\"language-text\">@AutoConfigureTestDatabase</code>를 조합해 사용하는 게 낫다. <code class=\"language-text\">JUnit 4</code>를 사용한다면 <code class=\"language-text\">@RunWith(SpringRunner.class)</code>를 함께 사용해야 한다.</p>\n</blockquote>\n<p>미션에서 <code class=\"language-text\">JdbcTemplate</code>만 주입 받으면 되는 <code class=\"language-text\">Dao</code> 객체들을 테스트하는 데 사용했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@JdbcTest</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JdbcLineDaoTest</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">LineDao</span> lineDao<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">JdbcLineDaoTest</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">JdbcTemplate</span> jdbcTemplate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lineDao <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JdbcLineDao</span><span class=\"token punctuation\">(</span>jdbcTemplate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Repository</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JdbcLineDao</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">LineDao</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">NamedParameterJdbcTemplate</span> jdbcTemplate<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">JdbcLineDao</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">JdbcTemplate</span> jdbcTemplate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>jdbcTemplate <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NamedParameterJdbcTemplate</span><span class=\"token punctuation\">(</span>jdbcTemplate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>자바독에서 볼 수 있듯이 해당 어노테이션을 적용한 테스트는 인메모리 DB로 테스트를 시행하며, 트랜젝션과 자동 롤백을 지원하게 된다. 또한, 스프링 컨테이너에 전체 컴포넌트를 등록하지 않아 테스트 비용을 절감할 수 있다.</p>\n<h2 id=\"webmvctest\" style=\"position:relative;\"><a href=\"#webmvctest\" aria-label=\"webmvctest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@WebMvcTest</h2>\n<blockquote>\n<p><code class=\"language-text\">스프링 MVC</code> 컴포넌트만 테스트하기 위한 어노테이션이다. 이 어노테이션을 사용하면 auto-configuration이 비활성화 되고, MVC 테스트와 관련된 configuration들만 적용된다. (ex. @Controller, @ControllerAdvice, @JsonComponent, Converter/GenericConverter, Filter, WebMvcConfigurer and HandlerMethodArgumentResolver 빈들, 다만 <strong>@Component, @Service, @Repository 빈들 제외</strong>)<br>\n기본적으로 <code class=\"language-text\">@WebMvcTest</code>가 사용된 테스트는 스프링 시큐리티와 MockMvc를 자동 설정한다. (HtmlUnit WebClient와 Selenium WebDriver 지원 포함) MockMvc에 대한 더욱 세밀한 설정을 위해 <code class=\"language-text\">@AutoConfigureMockMvc</code>를 사용할 수 있다. 일반적으로 <code class=\"language-text\">@WebMvcTest</code>를 사용할 때, <code class=\"language-text\">@Controller</code> 빈에 필요한 객체를 <code class=\"language-text\">@MockBean</code>이나 <code class=\"language-text\">@Import</code>를 통해 생성한다.<br>\n전체 어플리케이션 configuration을 로드하면서 <code class=\"language-text\">MockMvc</code>를 사용하고 싶다면, 이 어노테이션 보다 <code class=\"language-text\">@SpringBootTest</code>와 <code class=\"language-text\">@AutoConfigureMockMvc</code>를 함께 사용하는 게 낫다. <code class=\"language-text\">JUnit 4</code>를 사용한다면 <code class=\"language-text\">@RunWith(SpringRunner.class)</code>를 함께 사용해야 한다.</p>\n</blockquote>\n<p>미션에서 <em>컨트롤러만 단위 테스트</em>할 때 사용했다. 괄호 안에 테스트 할 특정 클래스를 적어주면 해당 클래스만 생성된다. MVC에 관련 된 빈만 생성되고 컨트롤러에 주입되는 빈이 생성되지 않기 떄문에, <code class=\"language-text\">@MockBean</code>으로 필요한 빈을 생성해야 한다. 그렇지 않으면 <code class=\"language-text\">Failed to load ApplicationContext</code> 메시지와 함께 실행에 실패한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@WebMvcTest</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">LineController</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">LineControllerUnitTest</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">MockMvc</span> mockMvc<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@MockBean</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">LineService</span> lineService<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"번외\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%99%B8\" aria-label=\"번외 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>번외?</h3>\n<p>테스트 할 컨트롤러를 특정하지 않으면 모든 <code class=\"language-text\">@Controller</code> 빈이 등록된다. 처음에는 테스트 대상 클래스를 표기해야만 실행되는 줄 알았다. 그런데 공식 문서로 공부하고 보니 특정하지 않아 실패한 것이 아니라, 모든 컨트롤러에 필요한 모든 서비스(테스트 내에서 사용하지 않더라도)를 생성하지 않아서 실행되지 않은 것이었다. 따라서 그럴 일은 없겠지만, 컨트롤러를 특정하지 않으면 다음과 같이 <code class=\"language-text\">@MockBean</code>으로 몽땅 등록하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@WebMvcTest</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">LineControllerUnitTest</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">MockMvc</span> mockMvc<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@MockBean</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">LineService</span> lineService<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@MockBean</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">PathService</span> pathService<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@MockBean</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">StationService</span> stationService<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token comment\">// 외의 모든 컨트롤러에서 사용되는 모든 주입받을 객체  </span>\n<span class=\"token punctuation\">}</span>  </code></pre></div>\n<h2 id=\"springboottest\" style=\"position:relative;\"><a href=\"#springboottest\" aria-label=\"springboottest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@SpringBootTest</h2>\n<blockquote>\n<p>스프링부트 기반 테스트를 위한 어노테이션이다. <code class=\"language-text\">Spring TestContext Framework</code>에 더해 다음과 같은 기능을 제공한다.</p>\n<ul>\n<li><code class=\"language-text\">@ContextConfiguration(loader=...)</code>가 정의되어 있지 않다면, 기본 <code class=\"language-text\">ContextLoader</code>로 <code class=\"language-text\">SpringBootContextLoader</code>를 사용</li>\n<li>내부에 <code class=\"language-text\">@Configuration</code>이 없고 <code class=\"language-text\">classes</code>가 정의되어 있지 않다면, 자동으로 <code class=\"language-text\">@SpringBootConfiguration</code>을 탐색</li>\n<li><code class=\"language-text\">properties attribute</code>를 이용한 <code class=\"language-text\">Environment</code> 설정</li>\n<li><code class=\"language-text\">args attribute</code>를 통한 어플리케이션 arguments를 정의</li>\n<li>웹 서버를 <code class=\"language-text\">defined</code> 또는 <code class=\"language-text\">random</code> 포트에서 구동 시킬지를 포함해, 여러 <code class=\"language-text\">webEnviroment</code> 모드를 설정</li>\n<li>웹 서버를 구동하는 웹 테스트에서 <code class=\"language-text\">TestRestTemplate, WebTestClient</code> 빈을 등록</li>\n</ul>\n</blockquote>\n<p>모든 객체를 실제 빈으로 등록하고 사용하는 컨트롤러 통합 테스트와 인수 테스트에서 해당 어노테이션을 사용했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 컨트롤러 통합 테스트  </span>\n<span class=\"token annotation punctuation\">@SpringBootTest</span>\n<span class=\"token annotation punctuation\">@AutoConfigureMockMvc</span>\n<span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token annotation punctuation\">@Sql</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/testSchema.sql\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LineControllerIntegrationTest</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">MockMvc</span> mockMvc<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 인수 테스트</span>\n<span class=\"token annotation punctuation\">@SpringBootTest</span><span class=\"token punctuation\">(</span>webEnvironment <span class=\"token operator\">=</span> <span class=\"token class-name\">SpringBootTest<span class=\"token punctuation\">.</span>WebEnvironment</span><span class=\"token punctuation\">.</span><span class=\"token constant\">RANDOM_PORT</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@DirtiesContext</span><span class=\"token punctuation\">(</span>classMode <span class=\"token operator\">=</span> <span class=\"token class-name\">DirtiesContext<span class=\"token punctuation\">.</span>ClassMode</span><span class=\"token punctuation\">.</span><span class=\"token constant\">BEFORE_EACH_TEST_METHOD</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Sql</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/testSchema.sql\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AcceptanceTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@LocalServerPort</span>\n    <span class=\"token keyword\">int</span> port<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@BeforeEach</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">RestAssured</span><span class=\"token punctuation\">.</span>port <span class=\"token operator\">=</span> port<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>모든 빈을 생성하기 때문에 비용과 실행 시간이 제일 많이 든다. 특히 <code class=\"language-text\">@DirtiesContext</code>로 매 테스트 마다 새로운 컨테이너를 생성하면 정말 끝내주는 실행 속도를 보여준다.</p>\n<br/>\n<p>어플리케이션 규모가 커지고 테스트 수가 늘어나면서 각 경우에 적절한 테스트를 설정하는 것이 중요해졌다. 사실 성격이 느긋해서 테스트에 시간이 많이 걸려도 신경쓰지 않는 편이었는데… 인수테스트를 필요에 따라 <code class=\"language-text\">@DirtiesContext</code>와 함께 쓰면서 테스트에 소모되는 비용과 시간 절약을 자연스레 고려하게 되었다. 이 외에도 다양한 테스트용 어노테이션과 추가 설정 가능한 사항들이 있는데, 아는 것만 쓰지 말고 더 넓게 학습해 더 나은 효율의 테스트를 작성하고 싶다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#jdbctest\">@JdbcTest</a></p>\n</li>\n<li>\n<p><a href=\"#webmvctest\">@WebMvcTest</a></p>\n<ul>\n<li><a href=\"#%EB%B2%88%EC%99%B8\">번외?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#springboottest\">@SpringBootTest</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"May 29, 2022","title":"[Spring] @JdbcTest, @WebMvcTest, @SpringBootTest","categories":"Spring","author":"써머","emoji":"headers/test-annotations.png"},"fields":{"slug":"/test-annotations/"}},"site":{"siteMetadata":{"siteUrl":"https://hyewoncc.github.io","comments":{"utterances":{"repo":"hyewoncc/hyewoncc.github.io"}}}}},"pageContext":{"slug":"/sql-no-wildcard/","nextSlug":"/optional-and-method-naming/","prevSlug":"/test-annotations/"}},"staticQueryHashes":["1073350324","1956554647","2938748437","3350743975"]}